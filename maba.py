"""
Mass Backtester
https://github.com/rulibar/mass-backtester

Gets data files from data_dir with the following format:
btc_eth_120m_200101-200301.txt
[
    1573502400000,      // Open time
    '0.02128900',       // Open
    '0.02130100',       // High
    '0.02126800',       // Low
    '0.02130000',       // Close
    '3221.45600000',    // Volume
    1573509599999,      // Close time
    '68.56577333',      // Quote asset volume
    5295,               // Number of trades
    '1564.35900000',    // Taker buy base asset volume
    '33.29836240',      // Taker buy quote asset volume
    '0'                 // Ignore
]
Generated by get_data.py.
n_early_candles will be skipped from the beginning and only used to calculate indicators.
The first entry in the data is the oldest.
Backtests the strategy on each dataset and creates a summary of the results.
"""

import os
import time
import numpy
import random
import logging
import talib

# user vars
n_early_candles = 600
data_dir = "data/"
start_pos = [0, 1] # [asset, base]

# set up logger
def set_log_file(ts, dsname):
    # Set up the log folders
    gmt = time.gmtime(ts / 1000)
    asct = time.asctime(gmt)
    yy = str(gmt.tm_year)[2:]; mm = str(gmt.tm_mon); dd = str(gmt.tm_mday)
    if len(mm) == 1: mm = "0" + mm
    if len(dd) == 1: dd = "0" + dd
    path = "./logs/"
    if not os.path.isdir(path): os.mkdir(path)
    path += "{}/".format(dsname)
    if not os.path.isdir(path): os.mkdir(path)
    path += "{}/".format(yy + mm)
    if not os.path.isdir(path): os.mkdir(path)
    # Set the log destination and format
    fileh = logging.FileHandler("./logs/{}/{}/{}.log".format(dsname, yy + mm, yy + mm + dd), "a")
    formatter = logging.Formatter("%(levelname)s {} - %(message)s".format(asct))
    fileh.setFormatter(formatter)
    logger.handlers = [fileh]

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger()

# set up backtester
def fix_dec(float_in):
    float_out = "{:.8f}".format(float_in)
    while float_out[-1] == "0": float_out = float_out[:-1]
    if float_out[-1] == ".": float_out = float_out[:-1]
    return float_out

def shrink_list(list_in, size) -> list:
    if len(list_in) > size: return list_in[-size:]
    return list_in

class Portfolio:
    def __init__(self, candle, positions, funds):
        self.ts = candle['ts_end']
        self.asset = positions['asset'][1]
        self.base = positions['base'][1]
        self.price = candle['close']
        self.positionValue = self.price * self.asset
        self.size = self.base + self.positionValue
        self.funds = funds
        if funds > self.size or funds == 0: self.funds = float(self.size)
        self.sizeT = float(self.funds)
        self.rin = self.price * self.asset / self.size
        self.rinT = self.price * self.asset / self.sizeT

class BacktestData:
    def __init__(self, backtest):
        # backtest is a completed Backtest object
        self.dspath = backtest.dspath
        self.dsname = backtest.dsname

        self.ticks = backtest.ticks; self.days = backtest.days; self.trades = backtest.trades
        self.exchange = "binance"
        self.base = backtest.base
        self.asset = backtest.asset
        self.pair = backtest.pair
        self.interval = backtest.interval
        self.params = backtest.params

        self.min_order = backtest.min_order
        self.amt_dec = backtest.amt_dec
        self.pt_dec = backtest.pt_dec

        self.candle_start = backtest.candle_start
        self.candle = backtest.candles[-1]
        self.positions_start = backtest.positions_start
        self.positions = backtest.positions

        self.signal = backtest.signal
        self.performance = backtest.performance

class Backtest:
    def __init__(self, dspath):
        # Expected dspath format: './data/btc_xrp_120m_200101-200301.txt'
        self.dspath = dspath
        self.dsname = dspath.split('/')
        self.dsname = self.dsname[-1][:-4]
        self.dsname_data = self.dsname.split('_')
        with open(self.dspath) as data: self.data = data.read()
        self.data = self.data.split('\n')[:-1]
        self.data = [eval(dat) for dat in self.data]

        self.next_log = 0
        self.ticks = 0; self.days = 0; self.trades = 0
        self.exchange = "binance"
        self.base = self.dsname_data[0].upper()
        self.asset = self.dsname_data[1].upper()
        self.pair = self.asset + self.base
        self.interval = int(self.dsname_data[2][:-1])
        set_log_file(self.data[n_early_candles][0], self.dsname)
        logger.info("New trader instance started on {} {}m.".format(self.pair, self.interval))
        self.get_params()

        self.candles_data = [self.get_candle(dat) for dat in self.data]
        self.candles = self.candles_data[:n_early_candles + 1]

        # backtester vars
        self.ticks_end = int(len(self.candles_data) - n_early_candles)
        self.min_order = 0
        self.amt_dec = 8
        self.pt_dec = 8

        self.candle_start = None
        self.positions_start = None
        self.positions = {"asset": [self.asset, float(start_pos[0])], "base": [self.base, float(start_pos[1])]}
        self.positions_f = {'asset': list(self.positions['asset'])}
        self.positions_f['base'] = list(self.positions['base'])
        self.positions_t = {'asset': list(self.positions['asset'])}
        self.positions_t['base'] = list(self.positions['base'])
        p = Portfolio(self.candles[-1], self.positions, float(self.params['funds']))
        self.last_order = {"type": "none", "amt": 0, "pt": self.candles[-1]['close']}
        self.signal = {"rinTarget": p.rinT, "rinTargetLast": p.rinT, "position": "none", "status": 0, "apc": p.price, "target": p.price, "stop": p.price}
        self.performance = {"bh": 0, "change": 0, "W": 0, "L": 0, "wSum": 0, "lSum": 0, "w": 0, "l": 0, "be": 0, "aProfits": 0, "bProfits": 0, "cProfits": 0}
        self.init(p)

    def get_candle(self, data):
        # data is a kline list from Binance
        candle = {
            "ts_start": int(data[0]),
            "open": round(float(data[1]), 8),
            "high": round(float(data[2]), 8),
            "low": round(float(data[3]), 8),
            "close": round(float(data[4]), 8),
            "volume": round(float(data[5]), 8),
            "ts_end": int(data[6])}
        return candle

    def limit_buy(self, amt, pt):
        logger.warning("Trying to buy {} {} for {} {}. (price: {})".format(fix_dec(amt), self.asset, fix_dec(round(amt * pt, self.pt_dec)), self.base, fix_dec(pt)))
        self.last_order = {"type": "buy", "amt": amt, "pt": pt}

    def limit_sell(self, amt, pt):
        logger.warning("Trying to sell {} {} for {} {}. (price: {})".format(fix_dec(amt), self.asset, fix_dec(round(amt * pt, self.pt_dec)), self.base, fix_dec(pt)))
        self.last_order = {"type": "sell", "amt": amt, "pt": pt}

    def bso(self, p):
        s = self.signal

        rbuy = s['rinTarget'] - s['rinTargetLast']
        order_size = 0
        if rbuy * p.asset >= 0:
            order_size = abs(rbuy * p.funds)
            if order_size > p.base: order_size = p.base
        if rbuy * p.asset < 0:
            rbuy_asset = rbuy / s['rinTargetLast']
            order_size = abs(rbuy_asset * p.asset * p.price)
        if order_size < self.min_order: order_size = 0

        if order_size > 0:
            if rbuy > 0: pt = (1 + 0.0015) * p.price
            else: pt = (1 - 0.0015) * p.price
            pt = round(pt, self.pt_dec)
            if rbuy > 0: amt = order_size / pt
            else: amt = order_size / p.price
            amt = round(0.995 * amt * 10**self.amt_dec - 2) / 10**self.amt_dec
            if rbuy > 0: self.limit_buy(amt, pt)
            if rbuy < 0: self.limit_sell(amt, pt)
        if rbuy == 0: order_size = 0
        if order_size == 0:
            if self.ticks == 1: logger.info("Waiting for a signal to trade...")
            self.last_order = {"type": "none", "amt": 0, "pt": p.price}

    def get_params(self):
        # import and process params
        params = dict()
        with open("config.txt") as cfg:
            par = [l.split()[0] for l in cfg.read().split("\n")[2:-1]]
            for p in par:
                p = p.split("=")
                if len(p) != 2: continue
                params[str(p[0])] = str(p[1])

        # check values
        funds = float(params['funds'])
        if funds < 0:
            logger.warning("Warning! Maximum amount to invest should be zero or greater.")
            params['funds'] = "0"

        logs_per_day = float(params['logs_per_day'])
        if logs_per_day < 0:
            logger.warning("Warning! Logs per day should be zero or greater.")
            params['logs_per_day'] = "1"

        log_dws = str(params['log_dws'])
        if log_dws not in {"yes", "no"}:
            logger.warning("Warning! Log deposits and withdrawals set to 'yes'.")
            params['log_dws'] = "yes"

        # check for additions and removals
        if self.ticks == 0: self.params = dict()

        keys_old = {key for key in self.params}
        keys_new = {key for key in params}

        keys_added = {key for key in keys_new if key not in keys_old}
        keys_removed = {key for key in keys_old if key not in keys_new}

        if len(keys_added) > 0:
            logger.info("{} parameter(s) added.".format(len(keys_added)))
            for key in keys_added: logger.info("    \"{}\": {}".format(key, params[key]))
        if len(keys_removed) > 0:
            logger.info("{} parameter(s) removed.".format(len(keys_removed)))
            for key in keys_removed: logger.info("    \"{}\"".format(key))

        # check for changes
        keys_remaining = {key for key in keys_old if key in keys_new}
        keys_changed = set()

        for key in keys_remaining:
            if params[key] != self.params[key]: keys_changed.add(key)

        if self.ticks == 0:
            keys_changed.add('funds'); keys_changed.add('logs_per_day'); keys_changed.add('log_dws')

        if "funds" in keys_changed:
            if params['funds'] == "0": logger.info("No maximum investment amount specified.")
            else: logger.info("Maximum investment amount set to {} {}.".format(params['funds'], self.base))
            self.params['funds'] = params['funds']
            keys_changed.remove('funds')
        if "logs_per_day" in keys_changed:
            if params['logs_per_day'] == "0": logger.info("Log updates turned off.")
            elif params['logs_per_day'] == "1": logger.info("Logs updating once per day.")
            else: logger.info("Logs updating {} times per day".format(params['logs_per_day']))
            self.params['logs_per_day'] = params['logs_per_day']
            keys_changed.remove('logs_per_day')
        if "log_dws" in keys_changed:
            if params['log_dws'] == "yes": logger.info("Deposit and withdrawal logs enabled.")
            else: logger.info("Deposit and withdrawal logs disabled.")
            self.params['log_dws'] = params['log_dws']
            keys_changed.remove('log_dws')

        if len(keys_changed) > 0:
            logger.info("{} parameter(s) changed.".format(len(keys_changed)))
            for key in keys_changed:
                logger.info("    \"{}\": {} -> {}".format(key, self.params[key], params[key]))
                self.params[key] = params[key]

    def get_new_candle(self):
        candle_new = self.candles_data[n_early_candles + self.ticks - 1]

        self.candles.append(candle_new)
        self.candles = shrink_list(self.candles, 5000)

    def get_positions(self):
        l = self.last_order
        l_type = l['type']; l_amt = l['amt']; l_pt = l['pt']
        positions = {key: value[:] for key, value in self.positions.items()}

        if l_type == 'buy':
            positions['base'][1] -= l_amt * l_pt
            positions['asset'][1] += l_amt * 0.999
        elif l_type == 'sell':
            positions['base'][1] += l_amt * l_pt * 0.999
            positions['asset'][1] -= l_amt

        return positions

    def update_f(self, p, apc):
        if apc == 0:
            if self.ticks != 1: return
            apc = p.price
        r = self.performance
        s = self.signal
        pos_f = self.positions_f
        pos_t = self.positions_t

        size = p.base + apc * p.asset
        rin = apc * p.asset / size
        sizeT = p.funds * (1 - s['rinTargetLast']) + apc * p.asset
        rinT = apc * p.asset / sizeT

        if self.ticks == 1: size_f = 1; size_t = 1
        else:
            size_f = pos_f['base'][1] + apc * pos_f['asset'][1]
            size_t = pos_t['base'][1] + apc * pos_t['asset'][1]
            if s['rinTarget'] == 0:
                profit = size_t - 1
                if profit >= 0: r['wSum'] += profit; r['W'] += 1; self.trades += 1
                if profit < 0: r['lSum'] += profit; r['L'] += 1; self.trades += 1
                if r['W'] != 0: r['w'] = r['wSum'] / r['W']
                if r['L'] != 0: r['l'] = r['lSum'] / r['L']
                size_t = 1

        base_f = (1 - rin) * size_f; base_t = (1 - rinT) * size_t
        asset_f = (rin / apc) * size_f; asset_t = (rinT / apc) * size_t

        pos_f['base'][1] = base_f; pos_t['base'][1] = base_t
        pos_f['asset'][1] = asset_f; pos_t['asset'][1] = asset_t

    def get_trades(self, p):
        l = self.last_order
        s = self.signal

        diffasset_trad = round(self.positions['asset'][1] - self.positions_last['asset'][1], 8)
        diffbase_trad = round(self.positions['base'][1] - self.positions_last['base'][1], 8)

        rbuy = s['rinTarget'] - s['rinTargetLast']
        rTrade = 1

        apc = 0
        if diffasset_trad != 0: apc = -diffbase_trad / diffasset_trad
        if diffasset_trad > 0:
            log_amt = "{} {}".format(fix_dec(diffasset_trad), self.asset)
            log_size = "{} {}".format(fix_dec(diffasset_trad * apc), self.base)
            logger.warning("{} bought for {}.".format(log_amt, log_size))
        elif diffasset_trad < 0:
            log_amt = "{} {}".format(fix_dec(-diffasset_trad), self.asset)
            log_size = "{} {}".format(fix_dec(-diffasset_trad * apc), self.base)
            logger.warning("{} sold for {}.".format(log_amt, log_size))

        if self.ticks == 1 or diffasset_trad != 0:
            s['rinTargetLast'] += rTrade * rbuy
            self.update_f(p, apc)

        return diffasset_trad, diffbase_trad, apc

    def get_dwts(self, p):
        s = self.signal
        l = self.last_order

        # get dws and trades
        # no dws or manual trades in backtesting
        self.get_trades(p)

        # set position and apc
        apc = self.last_order['pt']
        if p.positionValue > self.min_order:
            if s['position'] != "long":
                s['position'] = "long"; s['apc'] = apc
        elif s['position'] != "none":
            s['position'] = "none"; s['apc'] = apc

        return

    def get_performance(self, p):
        if self.ticks == 1:
            self.candle_start = dict(self.candles[-1])
            self.positions_start = {key: value[:] for key, value in self.positions.items()}
        r = self.performance
        s = self.signal
        pos_f = self.positions_f
        pos_t = self.positions_t
        c_start = self.candle_start
        p_start = self.positions_start
        p_start_size = p_start['base'][1] + c_start['close'] * p_start['asset'][1]

        pfake_size = pos_f['base'][1] + p.price * pos_f['asset'][1]
        ptrade_size = pos_t['base'][1] + p.price * pos_t['asset'][1]

        r['bh'] = (p.price - c_start['close']) / c_start['close']
        r['change'] = (p.size - p_start_size) / p_start_size
        r['bProfits'] = pfake_size - 1
        r['aProfits'] = (1 + r['bProfits']) / (1 + r['bh']) - 1
        r['cProfits'] = ptrade_size - 1

        W = int(r['W']); w = float(r['w'])
        L = int(r['L']); l = float(r['l'])
        if r['cProfits'] >= 0: W += 1; wSum = r['wSum'] + r['cProfits']; w = wSum / W
        if r['cProfits'] < 0: L += 1; lSum = r['lSum'] + r['cProfits']; l = lSum / L
        r['be'] = W * w + L * l

    def log_update(self, p):
        r = self.performance

        hr = "~~~~~~~"
        tpd = float()
        if self.days != 0: tpd = self.trades / self.days
        winrate = float()
        if r['W'] + r['L'] != 0: winrate = 100 * r['W'] / (r['W'] + r['L'])
        header = "{} {} {} {} {}".format(self.bot_name, self.version, hr, self.exchange.title(), self.pair)
        trades = "{} trades ({} per day)".format(int(self.trades), round(tpd, 2))
        currency = "{} {}".format(fix_dec(p.base), self.base)
        price = "{} {}/{}".format(fix_dec(p.price), self.base, self.asset)
        assets = "{} {}".format(fix_dec(p.asset), self.asset)
        assetvalue = "{} {}".format(fix_dec(p.positionValue), self.base)
        accountvalue = "{} {}".format(fix_dec(p.size), self.base)
        boteff = "{}% {},".format(round(100 * r['be'], 2), self.base)
        boteff += " {}% {}".format(round(100 * ((1 + r['be']) / (1 + r['bh'])) - 100, 2), self.asset)
        botprof = "{}% {},".format(round(100 * r['bProfits'], 2), self.base)
        botprof += " {}% {}".format(round(100 * ((1 + r['bProfits']) / (1 + r['bh'])) - 100, 2), self.asset)

        logger.info("{} {} {}".format(2 * hr, header, 2 * hr))
        logger.info("Days since start: {} | Trades: {}".format(round(self.days, 2), trades))
        logger.info("Currency: {} | Current price: {}".format(currency, price))
        logger.info("Assets: {} | Value of assets: {}".format(assets, assetvalue))
        logger.info("Value of account: {}".format(accountvalue))
        logger.info("    Win rate: {}%".format(round(winrate, 2)))
        logger.info("    Wins: {} | Average win: {}%".format(r['W'], round(100 * r['w'], 2)))
        logger.info("    Losses: {} | Average loss: {}%".format(r['L'], round(100 * r['l'], 2)))
        logger.info("    Current profits: {}%".format(round(100 * r['cProfits'], 2)))
        logger.info("    Bot efficiency: {}".format(boteff))
        logger.info("Bot profits: {}".format(botprof))
        logger.info("Buy and hold: {}%".format(round(100 * r['bh'], 2)))

    def init(self, p):
        self.bot_name = "maba"
        self.version = "0.0.0"
        logger.info("Analyzing the market...")
        # get randomization
        # no randomization yet
        logger.info("Ready to start trading...")

    def strat(self, p):
        """ strategy / trading algorithm
        - Use talib for indicators
        - Talib objects require numpy.array objects as input
        - s stands for signal, rinTarget stands for 'ratio invested target'
        - Set s['rinTarget'] between 0 and 1. 0 is 0%, 1 is 100% invested
        """
        s = self.signal

        close_data = numpy.array([c['close'] for c in self.candles])
        mas = talib.SMA(close_data, timeperiod = 20)[-1]
        mal = talib.SMA(close_data, timeperiod = 100)[-1]

        s['rinTarget'] = 0
        if mas > mal: s['rinTarget'] = 1

    def run(self):
        print(self.dsname)

        while self.ticks < self.ticks_end:
            # Preliminary setup
            self.ticks += 1
            self.days = (self.ticks - 1) * self.interval / (60 * 24)
            set_log_file(self.data[n_early_candles + self.ticks - 1][0], self.dsname)
            self.get_new_candle()

            self.positions_last = {key: value[:] for key, value in self.positions.items()}
            self.positions = self.get_positions()
            p = Portfolio(self.candles[-1], self.positions, float(self.params['funds']))
            self.get_dwts(p)
            self.get_performance(p)

            # Log output
            if self.params['logs_per_day'] == "0": self.next_log = self.days + 1
            if self.days >= self.next_log:
                self.log_update(p)
                self.next_log += 1 / float(self.params['logs_per_day'])

            # Trading strategy, buy/sell/other
            self.strat(p)
            self.bso(p)

        print("Backtest complete.")

# main code
datasets = os.listdir(data_dir)
backtests = list()

# cycle through the data
for dataset in datasets:
    # Initialize the Backtest instance
    data_path = "./" + data_dir + dataset
    backtest = Backtest(data_path)

    # Run the backtest
    backtest.run()

    # Save the relevant data from the Backtest instance
    backtest_data = BacktestData(backtest)
    backtests.append(backtest_data)

# create the summary
for backtest in backtests:
    print(backtest.performance)
    print(backtest.dsname)
